package com.shopper.shopperapi.services;

import java.util.*;

import com.google.firebase.database.*;
import net.minidev.json.JSONObject;
import com.shopper.shopperapi.utils.distance.DistanceCalculated;
import org.bson.types.ObjectId;
import org.springframework.boot.configurationprocessor.json.JSONException;

import com.shopper.shopperapi.models.Order;
import com.shopper.shopperapi.models.OrderShopper;
import com.shopper.shopperapi.models.Shop;
import com.shopper.shopperapi.models.User;
import com.shopper.shopperapi.repositories.OrderRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import static com.shopper.shopperapi.utils.notification.OrderState.PENDING_ORDER_STATE;
import static com.shopper.shopperapi.utils.notification.OrderState.isOrderTakenState;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Nullable;

@Service
public class OrderService {
	@Autowired
	private OrderRepository orderRepository;
	@Autowired
	private UserService userService;
	@Autowired
	private ShopService shopService;
	@Autowired
	private DatabaseReference databaseReference;
	@Autowired
	private RestTemplate restTemplate;
	private final String DJANGO_API = "http://54.200.195.251/api/pagos/";

	/**
	 * TODO: Funcionalidad para ubicar al shopper(S) más cercano al customer
	 */

	// History of orders
	public List<Order> finAll(){
		return this.orderRepository.findAll();
	}

	/**
	 * Método para crear una orden
	 * @param order objeto Order
	 * @return Order
	 */
	@Transactional
	public Order create(Order order) {
//        order.setId(ObjectId.get().toHexString());
		return this.orderRepository.save(order);
	}

	public String getOrderFirebaseDbRefKey(String orderId) {
		return orderRepository.findById(orderId).get().getFirebaseDbReferenceKey();
	}

	// Process order charge
	public boolean processOrder(Order order) throws JSONException {
		User customer = order.getCustomer();

		System.out.println(order.getSourceId());
		System.out.println(customer.getId());
		System.out.println(customer.getEmail());
		System.out.println(order.getTotalCost());

		if (order.getTotalCost() >= 300) {
			boolean cardVerified = cardOperation(order.getSourceId(), customer.getId(), customer.getEmail(), order.getTotalCost());

			if (cardVerified) {
				// Call to firebase database - publicar la orden y notificar a shoppera más cercanos
				newOrder(order);
				return true;
			} else {
				System.out.println("card problem");
				return false;
			}
		}

		System.out.println("Order not valid (not enough amount)");
		return false;
	}

	public boolean handleOrder(String orderFirebaseDbRefKey, int state, String shopperId) {
		// Petición para que el shopper acepte o cancele -> obtener codigo de estado 1 2 3
		try {
			updateOrderByState(orderFirebaseDbRefKey, state, shopperId);
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	// Expose order in Firebase cloud
	public void newOrder(Order order) {

		DatabaseReference ordersRef = databaseReference.child("orders");

		// Generate a reference to a new location and add some data using push()
		DatabaseReference pushedOrderRef = ordersRef.push();

		// Get the unique ID generated by a push()
		String orderFirebaseDbRefKey = pushedOrderRef.getKey();
		order.setFirebaseDbReferenceKey(orderFirebaseDbRefKey);
		order.setId(ObjectId.get().toHexString());
		order.setState(PENDING_ORDER_STATE.getState());

		// Hide sensitive data
		if (order.getShopper() != null) {
			order.getShopper().setPassword(null);
		}

		order.getCustomer().setPassword(null);

		ordersRef.child(orderFirebaseDbRefKey).setValue(order, (databaseError, databaseReference) -> {
			if (databaseError != null) {
				System.out.println("Data could not be saved " + databaseError.getMessage());
			} else {
				// Notificar al shopper(s) más cercano
				System.out.println("Order data saved successfully.");

				// ...
			}
		});
	}

	public void deleteFirebaseOrder(Order order) {

		System.out.println("ORDER TO DELETE:");
		System.out.println(order);

		try {
			Order orderAdded = orderRepository.save(order);
			System.out.println("Order in Mongo:");
			System.out.println(orderAdded);
		} catch (Exception e) {
			System.out.println("Exception");
			System.out.println(e);
		}

		DatabaseReference ordersRef = databaseReference.child("orders");

		String dbKey = order.getFirebaseDbReferenceKey();

		System.out.println("LLAVE A REMOVER DE FIREBASE: " + dbKey);

		ordersRef.child(dbKey).removeValue((databaseError, databaseReference) -> {
			if (databaseError != null) {
				System.out.println("Data could not be saved " + databaseError.getMessage());
			} else {
				System.out.println("Order data saved successfully.");
			}
		});
	}

	public void updateOrderByState(String orderFirebaseDbRefKey, int state, @Nullable String idShopper) {

		DatabaseReference ordersRef = databaseReference.child("orders");

		System.out.println("SE ACTUALIZARA EL ESTADO DE LA ORDEN : " + orderFirebaseDbRefKey);
		System.out.println("QUE SHOPPER TOMÓ LA ORDEN: " + idShopper);

		Map<String, Object> newOrderState = new HashMap<>();

		if (isOrderTakenState(state) && idShopper != null) {
			newOrderState.put("shopper", userService.findById(new ObjectId(idShopper)).get());
		}

		newOrderState.put("state", state);

		ordersRef.child(orderFirebaseDbRefKey).updateChildren(newOrderState, (databaseError, databaseReference) -> {
			if (databaseError != null) {
				System.out.println("Order could not be updated " + databaseError.getMessage());
			} else {
				// Notificar al shopper(s) más cercano
				System.out.println("Order data updated successfully.");

				// ...

			}
		});
	}

	public boolean cardOperation(String sourceId, String customerId, String customerEmail, int totalCost) throws JSONException {

		boolean success;

		JSONObject param = new JSONObject();
		param.put("amount", totalCost);
		param.put("currency_code", "PEN");
		param.put("description", "appOrder-" + customerId);
		param.put("email", customerEmail);
		param.put("source_id", sourceId);

		HttpEntity<String> httpEntity = new HttpEntity<>(param.toString());

		ResponseEntity<String> 	msm = restTemplate.exchange(DJANGO_API, HttpMethod.POST, httpEntity, String.class);

		if (msm.getBody().equals("201")) {
			success = true;
		} else {
			success = false;
		}

		return success;
	}

	/**
	 * Método para obtener lista de SHOPPERS más cercanos al pedido en orden de distancia
	 * @param idShop-
	 * @return List<String>
	 */
	public List<String> shoperList(String idShop) {

		List<User> usuario = userService.findByRole("ROLE_SHOPPER");
		List<OrderShopper> orderShopper = new ArrayList<>();
		List<String> notification_key = new ArrayList<>();
		Shop shop = shopService.findById(new ObjectId(idShop));

		for (User user : usuario) {
			Double distancia = DistanceCalculated.distanceCoord(user.getUserLat(), user.getUserLng(), shop.getShopLat(), shop.getShopLng());
			if (distancia <= 100) {
				orderShopper.add(new OrderShopper(distancia, user.getNotificationDeviceGroup().get("notification_key")));
			}
		}

		orderShopper.sort(Comparator.comparing(OrderShopper::getDistance));

		for (OrderShopper orderShopper2 : orderShopper) {
			notification_key.add(orderShopper2.getNotification_key());
		}

		return notification_key;
	}
}
