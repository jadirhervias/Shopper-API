package com.shopper.shopperapi.services;

import java.util.*;

import com.google.firebase.database.*;
import com.shopper.shopperapi.models.*;
import com.shopper.shopperapi.utils.distance.DistanceCalculated;
import com.shopper.shopperapi.utils.notification.OrderState;
import org.bson.types.ObjectId;
import org.springframework.boot.configurationprocessor.json.JSONException;
import org.springframework.boot.configurationprocessor.json.JSONObject;

import com.shopper.shopperapi.repositories.OrderRepository;

import com.shopper.shopperapi.utils.FirebaseConfiguration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import static com.shopper.shopperapi.utils.notification.NotificationMessages.*;
import static com.shopper.shopperapi.utils.notification.OrderState.*;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Nullable;

@Service
public class OrderService {
	@Autowired
	private OrderRepository orderRepository;
	@Autowired
	private UserService userService;
	@Autowired
	private ShopService shopService;
	@Autowired
	private DatabaseReference databaseReference;
//	@Autowired
//	private FCMService fcmService;
//	@Autowired
//	private FirebaseConfiguration firebaseConfiguration;
//	@Autowired
//	private ChildEventListener orderAddChildEventListener;
	@Autowired
	private RestTemplate restTemplate;

	private final String django = "http://54.200.195.251/api/pagos/";

	public OrderService() {
	}

	/**
	 * TODO: Funcionalidad para ubicar al shopper(S) más cercano al customer
	 */

	// History of orders
	public List<Order> finAll(){
		return this.orderRepository.findAll();
	}

	/**
	 * Método para crear una orden
	 * @param order
	 * @return Order
	 */
	@Transactional
	public Order create(Order order) {
//        shop.setId(ObjectId.get());
		return this.orderRepository.save(order);
	}

	public String getOrderFirebaseDbRefKey(String orderId) {
		return orderRepository.findById(orderId).get().getFirebaseDbReferenceKey();
	}

	// Process order charge
	public boolean processOrder(Order order
//								, Charge charge, String customerNotificationKey, String orderFirebaseDbRefKey
	) throws JSONException {

		User customer = order.getCustomer();

		System.out.println(">>>>>>>>> CUSTOMER OF THE ORDER: " + customer.toString());

		boolean cardVerified = cardOperation(order.getSourceId(), customer.getId(), customer.getEmail(), order.getTotalCost());
		if (cardVerified) {
			// Obtener lista de notification keys de shopper más cercano(s)
//			List<String> shoppersDeviceGroupKeys = shoperList(order.getShopId());
//			"APA91bHhj2mg_MVQHPouK7WwkUb9xlhd52q4kQS9-OGKKBC1eo3L1A3UWb1MbH-ELXKf8Z3nslRfC-l-cGHp6bxEynD8k19axMEmL5c0BVK_elF-l3jyAzvvEl6-BCYQjOfBG-t4LXqDzgO_vED6t3qQCvuC9fbwvw"

			// Call to firebase database - publicar la orden y notificar a shoppera más cercanos
			newOrder( order
//					, customerNotificationKey
//					, shoppersDeviceGroupKeys
			);

			return true;

		} else {
			System.out.println("card problem");
			return false;
		}
	}

	public boolean handleOrder(String orderFirebaseDbRefKey, int state, String shopperId) {
		// Petición para que el shopper acepte o cancele -> obtener codigo de estado 1 2 3
		try {
			updateOrderByState(orderFirebaseDbRefKey, state, shopperId);
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	// Expose order in Firebase cloud
	public void newOrder(
			Order order
//			String customerNotificationKey, List<String> shoppersDeviceGroupKey
	) {

		DatabaseReference ordersRef = databaseReference.child("orders");

		// Generate a reference to a new location and add some data using push()
		DatabaseReference pushedOrderRef = ordersRef.push();

		// Get the unique ID generated by a push()
		String orderFirebaseDbRefKey = pushedOrderRef.getKey();
		order.setFirebaseDbReferenceKey(orderFirebaseDbRefKey);
		order.setState(PENDING_ORDER_STATE.getState());

		// Hide sensitive data
		if (order.getShopper() != null) {
			order.getShopper().setPassword(null);
		}

		order.getCustomer().setPassword(null);

		ordersRef.child(orderFirebaseDbRefKey).setValue(order, (databaseError, databaseReference) -> {
			if (databaseError != null) {
				System.out.println("Data could not be saved " + databaseError.getMessage());
			} else {
				// Notificar al shopper(s) más cercano
				System.out.println("Order data saved successfully.");

				// ...

//				List<String> shoppersDeviceGroupKeys = shoperList(order.getShopId());
//				fcmService.sendPushNotificationToShoppers(customerNotificationKey, shoppersDeviceGroupKeys ,
//						MESSAGE_TITLE.getMessage(), NEW_ORDER_MESSAGE_BODY.getMessage(), orderFirebaseDbRefKey);
			}
		});

		// ordersRef.child(orderId).setValueAsync(order);
	}

	// En función del request del shopper o customer
	public void updateOrderByState(String orderFirebaseDbRefKey, int state, @Nullable String idShopper) {
		DatabaseReference ordersRef = databaseReference.child("orders");

		Map<String, Object> newOrderState = new HashMap<>();

		if (isOrderTakenState(state) && idShopper != null) {
			newOrderState.put("shopper", userService.findById(new ObjectId(idShopper)));
		}

		newOrderState.put("state", state);

		ordersRef.child(orderFirebaseDbRefKey).updateChildren(newOrderState, (databaseError, databaseReference) -> {
			if (databaseError != null) {
				System.out.println("Order could not be updated " + databaseError.getMessage());
			} else {
				// Notificar al shopper(s) más cercano
				System.out.println("Order data updated successfully.");

				// ...

			}
		});
	}

	public boolean cardOperation(String sourceId, String customerId, String customerEmail, int totalCost) throws JSONException {

		boolean success;

		JSONObject param = new JSONObject();
		param.put("amount", totalCost);
		param.put("currency_code", "PEN");
		param.put("description", "appOrder-" + customerId);
		param.put("email", customerEmail);
		param.put("source_id", sourceId);

		HttpEntity<String> httpEntity = new HttpEntity<>(param.toString());

		ResponseEntity<String> 	msm = restTemplate.exchange(django, HttpMethod.POST, httpEntity, String.class);

		if (msm.getBody().equals("201")) {
			success = true;
		} else {
			success = false;
		}

		return success;
	}

	/**
	 * Método para obtener lista de SHOPPERS más cercanos al pedido en orden de distancia
	 * @param id_shop-
	 * @return List<String>
	 */
	public List<String> shoperList(String id_shop) {

		List<User> usuario = userService.findByRole("ROLE_SHOPPER");
		List<OrderShopper> orderShopper = new ArrayList<>();
		List<String> notification_key = new ArrayList<>();
		Shop shop = shopService.findById(new ObjectId(id_shop));

		for (User user : usuario) {
			Double distancia = DistanceCalculated.distanceCoord(user.getUserLat(), user.getUserLng(), shop.getShopLat(), shop.getShopLng());
			if (distancia <= 100) {
				orderShopper.add(new OrderShopper(distancia, user.getNotificationDeviceGroup().get("notification_key")));
			}
		}

		orderShopper.sort(Comparator.comparing(OrderShopper::getDistance));

		for (OrderShopper orderShopper2 : orderShopper) {
			notification_key.add(orderShopper2.getNotification_key());
		}

		return notification_key;
	}
}
